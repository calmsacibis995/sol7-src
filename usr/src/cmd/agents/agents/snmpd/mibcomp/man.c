/* Copyright 1988 - 10/02/96 Sun Microsystems, Inc. All Rights Reserved.
 */

#if !defined(lint) && !defined(NOID)
#ifdef SVR4
#pragma ident  "@(#)man.c	2.16 96/10/02 Sun Microsystems"
#else
static char sccsid[] = "@(#)man.c	2.16 96/10/02 Sun Microsystems";
#endif
#endif

/*
** Sun considers its source code as an unpublished, proprietary trade 
** secret, and it is available only under strict license provisions.  
** This copyright notice is placed here only to protect Sun in the event
** the source is deemed a published work.  Disassembly, decompilation, 
** or other means of reducing the object code to human readable form is 
** prohibited by the license agreement under which this code is provided
** to the user or company in possession of this copy.
** 
** RESTRICTED RIGHTS LEGEND: Use, duplication, or disclosure by the 
** Government is subject to restrictions as set forth in subparagraph 
** (c)(1)(ii) of the Rights in Technical Data and Computer Software 
** clause at DFARS 52.227-7013 and in similar clauses in the FAR and 
** NASA FAR Supplement.
*/
/* man.c
 */

/* $Header: /projects/mibcomp/man.c,v 1.3 90/11/03 13:08:47 romkey Exp $ */

/* $Log:	man.c,v $
 * Revision 1.3  90/11/03  13:08:47  romkey
 * got rid of sys/types.h include
 * 
 * Revision 1.2  90/09/17  22:38:15  romkey
 * added copyright, filename and RCS info comments
 * 
 *
 * $Date: 90/11/03 13:08:47 $
 * $Revision: 1.3 $
 * $Author: romkey $
 */

/****************************************************************************
 *     Copyright (c) 1988-1990  Epilogue Technology Corporation
 *     All rights reserved.
 *
 *     This is unpublished proprietary source code of Epilogue Technology
 *     Corporation.
 *
 *     The copyright notice above does not evidence any actual or intended
 *     publication of such source code.
 ****************************************************************************
 */

#include <stdio.h>
#include <sys/types.h>
#include <time.h>

#include "mibcomp.h"

/* This file contains the code which writes a file of stub functions for 
 * a manager; eg: fetch_sysDescr, store_sysName, and also a set of arrays
 * providing the manager with an easy way to access the object id's.
 */

static void _write_ids(), _write_mib(), func_stub();

write_man(f, source_file)
	char *f;
	char *source_file; {
	FILE *fout;
	time_t now;
	char *s;

	fout = fopen(f, "w");
	if(fout == NULL) {
		perror(f);
		exit(1);
		}

	fprintf(fout, "/*****************************************************************************\n");
	fprintf(fout, " *****************************************************************************\n");
	fprintf(fout, " ****\t\t\tWARNING\n");
	fprintf(fout, " ****\t\n");
	fprintf(fout, " ****\tThis file is automatically generated by the Epilogue Technology\n");
	fprintf(fout, " ****\t MIB compiler.\n");
	fprintf(fout, " ****\t\n");
	fprintf(fout, " ****\tThis file contains functions to allow a manager to fetch and store\n");
	fprintf(fout, " ****\tMIB variables, and their object ID's.\n");
	fprintf(fout, " ****\t\n");
	fprintf(fout, " ****\tDO NOT MODIFY THIS FILE BY HAND\n");
	fprintf(fout, " ****\n");

	time(&now);
	fprintf(fout, " **** Last build date: %s", ctime(&now));
	fprintf(fout, " ****\tfrom file %s\n", source_file);
	fprintf(fout, " *****************************************************************************\n");
	fprintf(fout, " *****************************************************************************\n");

	fprintf(fout, " */\n\n\n");

	fprintf(fout, "#include <asn1.h>\n");
	fprintf(fout, "#include <snmp.h>\n");
	fprintf(fout, "#include <mib.h>\n");
	fprintf(fout, "#include <libfuncs.h>\n\n");

	if(root.kids == NULL) {
		fprintf(stderr, "warning: empty MIB\n");
		return 1;
		}

	/* generate all the object ID's
	 */
	_write_ids(fout, root.kids, "", 0);
	
	fprintf(fout, "\n\n");
#if	0
	fprintf(fout, "unsigned int req_id = 0;\n\n");

	/* walk the tree. Start at the root and work down.
	 */
	_write_mib(fout, &root);
#endif
	}

static void _write_ids(fout, tree, initial, idlen)
	FILE *fout;
	struct node *tree;
	char *initial;
	unsigned idlen; {
	struct node *kid;
	char objectid[128];

	if(strlen(initial)) {
		sprintf(objectid, "%s, %d", initial, tree->number);
		idlen++;
		}
	else {
		sprintf(objectid, "%d", tree->number);
		idlen = 1;
		}

	/* first, emit a node declaration if it's a node, or a leaf
	 * 	declaration if it's got no kids...
	 */
	if(tree->flags & FL_LEAF) {
		/* give us 10 extra zeroes
		 */
		strcat(objectid, ", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0");
		fprintf(fout, "OIDC_T ID_%s[] = { %s };\n",
			tree->name, objectid);
		fprintf(fout, "unsigned int len_%s = %d;\n", tree->name,
			idlen);
		}
	else {
		for(kid = tree->kids; kid; kid = kid->next)
			_write_ids(fout, kid, objectid, idlen);
		}
	}

static void _write_mib(fout, tree)
	FILE *fout;
	struct node *tree; {
	struct node *kid;

	/* first, emit a node declaration if it's a node, or a leaf
	 * 	declaration if it's got no kids...
	 */
	if(tree->kids || (!(tree->flags & FL_LEAF))) {
		/* if it's got kids, we've got to declare them first, so that
		 * we can build an arc out of them.
		 */
		for(kid = tree->kids; kid; kid = kid->next)
			_write_mib(fout, kid);
		}
	else
		if(tree->flags & FL_LEAF) {	/* only do this if a leaf */
			func_stub(fout, tree);
			}
	}

static void func_stub(fout, n)
	FILE *fout;
	struct node *n; {
	char *func;
	
	if((n->flags & FL_READABLE)) {
		fprintf(fout, "fetch_%s(from, community, comlen)\n",
			n->name);
		fprintf(fout, "\tunsigned char *from;\n");
		fprintf(fout, "\tunsigned char *community;\n");
		fprintf(fout, "\tunsigned comlen; {\n");
		fprintf(fout, "\tSNMP_PKT_T *rcvd_pkt;\n");
		fprintf(fout, "\tEBUFFER_T ebuff;\n");
		fprintf(fout, "\tint rcode;\n");
		fprintf(fout, "\tint sd;\n");

		fprintf(fout, "\trcvd_pkt = SNMP_Create_Request(GET_REQUEST_PDU, VERSION_RFC1067,\n");
		fprintf(fout, "\t\t\tcomlen, community,\n");
		fprintf(fout, "\t\t\t(INT_32_T)req_id++,\n");
		fprintf(fout, "\t\t\t1\n");

		fprintf(fout, "\trcode = SNMP_Bind_Null(rcvd_pkt, /* index to set */ 0,\n");
		fprintf(fout, "\t\t\tsizeof(ID_%s)/sizeof(unsigned int),\n",
			n->name);
		fprintf(fout, "\t\t\tID_%s\n", n->name);

		fprintf(fout, "\tEBufferInitialize(&ebuff);\n");

		fprintf(fout, "\trcode = SNMP_Encode_Packet(rcvd_pkt, &ebuff);\n");
		fprintf(fout, "\tSNMP_Free(rcvd_pkt);\n");

		fprintf(fout, "\tsendto(sd, ebuff.start_bp, EBufferUsed(&ebuff), 0, &dest, sizeof(dest));\n");

		fprintf(fout, "\tSNMP_mem_free(ebuff.start_bp);\n");
		fprintf(fout, "\tEBufferClean(&ebuff);\n");
		fprintf(fout, "\tszfrom = sizeof(from);\n");
		fprintf(fout, "\tif (recvfrom(sd, rcvbuff, sizeof(rcvbuff), 0, &from, &szfrom) == -1) {\n");
		fprintf(fout, "\t\tperror(\"Recvfrom failed\");\n");
		fprintf(fout, "\t\treturn -1;\n");
		fprintf(fout, "\t\t}\n\n");

		fprintf(fout, "\tif ((rcvd_pkt = SNMP_Decode_Packet(rcvbuff, sizeof(rcvbuff))) == (SNMP_PKT_T *)0) {\n");
		fprintf(fout, "\t\tSNMP_Free(rcvd_pkt);\n");
		fprintf(fout, "\t\texit(1);\n");
		fprintf(fout, "\t\t}\n\n");

		fprintf(fout, "\t}\n\n");
		}

	if((n->flags & FL_WRITEABLE)) {
		fprintf(fout, "store_%s(from, community, comlen, value, vallen)\n",
			n->name);
		fprintf(fout, "\tunsigned char *from;\n");
		fprintf(fout, "\tunsigned char *community;\n");
		fprintf(fout, "\tunsigned comlen;\n");
		fprintf(fout, "\tunsigned char *value;\n");
		fprintf(fout, "\tunsigned vallen; {\n");
		fprintf(fout, "\t}\n\n");
		}
	}

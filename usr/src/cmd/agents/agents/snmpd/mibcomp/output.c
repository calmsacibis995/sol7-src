/* Copyright 1988 - 10/02/96 Sun Microsystems, Inc. All Rights Reserved.
 */

#if !defined(lint) && !defined(NOID)
#ifdef SVR4
#pragma ident  "@(#)output.c	2.16 96/10/02 Sun Microsystems"
#else
static char sccsid[] = "@(#)output.c	2.16 96/10/02 Sun Microsystems";
#endif
#endif

/*
** Sun considers its source code as an unpublished, proprietary trade 
** secret, and it is available only under strict license provisions.  
** This copyright notice is placed here only to protect Sun in the event
** the source is deemed a published work.  Disassembly, decompilation, 
** or other means of reducing the object code to human readable form is 
** prohibited by the license agreement under which this code is provided
** to the user or company in possession of this copy.
** 
** RESTRICTED RIGHTS LEGEND: Use, duplication, or disclosure by the 
** Government is subject to restrictions as set forth in subparagraph 
** (c)(1)(ii) of the Rights in Technical Data and Computer Software 
** clause at DFARS 52.227-7013 and in similar clauses in the FAR and 
** NASA FAR Supplement.
*/
/* output.c
 */

/* $Header: /projects/mibcomp/output.c,v 1.4 90/11/03 13:07:16 romkey Exp Locker: romkey $ */

/* $Log:	output.c,v $
 * Revision 1.4  90/11/03  13:07:16  romkey
 * got rid of sys/types.h include
 * 
 * Revision 1.3  90/10/02  15:33:08  romkey
 * added code to generate LEAFM macros if DEFAULT locator, view_mask or write_mask
 * is used
 * 
 * Revision 1.2  90/09/17  22:38:21  romkey
 * added copyright, filename and RCS info comments
 * 
 *
 * $Date: 90/11/03 13:07:16 $
 * $Revision: 1.4 $
 * $Author: romkey $
 */

/****************************************************************************
 *     Copyright (c) 1988-1990  Epilogue Technology Corporation
 *     All rights reserved.
 *
 *     This is unpublished proprietary source code of Epilogue Technology
 *     Corporation.
 *
 *     The copyright notice above does not evidence any actual or intended
 *     publication of such source code.
 ****************************************************************************
 */

#include <stdio.h>
#include <time.h>
#include <sys/types.h>

#include "mibcomp.h"

char *strchr();
static void _write_mib();

write_mib(f, source_file)
	char *f;
	char *source_file; {
	FILE *fout;
	char *s;
	time_t now;

	fout = fopen(f, "w");
	if(fout == NULL) {
		perror(f);
		exit(1);
		}

	fprintf(fout, "/*****************************************************************************\n");
	fprintf(fout, " *****************************************************************************\n");
	fprintf(fout, " ****\t\t\tWARNING\n");
	fprintf(fout, " ****\tThis file is automatically generated by the Epilogue Technology\n");
	fprintf(fout, " ****\t MIB compiler. Do NOT edit it by hand.\n");
	fprintf(fout, " ****\n");

	time(&now);
	fprintf(fout, " **** Last build date: %s", ctime(&now));
	fprintf(fout, " ****\tfrom file %s\n", source_file);
	fprintf(fout, " *****************************************************************************\n");
	fprintf(fout, " *****************************************************************************\n");

	fprintf(fout, " */\n\n\n");

	fprintf(fout, "#define	_MIB	1\n");

	for(s = get_include(); s; s = get_include())
		fprintf(fout, "#include %s\n", s);

	fprintf(fout, "#define STATIC static\n\n");

	/* walk the tree. Start at the root and work down.
	 */
	_write_mib(fout, &root);
        return 1;
	}

static void _write_mib(fout, tree)
	FILE *fout;
	struct node *tree; {
	struct node *kid;
	char *s;

	/* regularize node name - convert any dashes into underscores
	 */
        while(s = strchr(tree->name, '-'))
		*s = '_';

	/* first, emit a node declaration if it's a node, or a leaf
	 * 	declaration if it's got no kids...
	 */
	if(tree->kids || (!(tree->flags & FL_LEAF))) {
		/* if it's got kids, we've got to declare them first, so that
		 * we can build an arc out of them.
		 */
		for(kid = tree->kids; kid; kid = kid->next)
			_write_mib(fout, kid);

		/* write the arc description
		 */
		fprintf(fout, "STATIC\n");
		fprintf(fout, "MIBARC_T\t%s_arcs[] = {\n", tree->name);

		for(kid = tree->kids; kid; kid = kid->next)
			fprintf(fout, "\t\t\tARC(%d, %s_%s),\n",
				kid->number, kid->name,
				kid->flags & FL_LEAF ? "leaf" : "node");

		fprintf(fout, "\t\t\tEND_OF_ARC_LIST };\n");

		if(!(tree->flags & FL_GLOBAL))
			fprintf(fout, "STATIC\n");

		fprintf(fout, "MIBNODE_T\t%s_node = NODE(\"%s\", %s_arcs);\n\n",
			tree->name, tree->name, tree->name);
		}
	else
		if(tree->flags & FL_LEAF) {	/* only do this if a leaf */
			char *testfunc;
			char *getfunc;
			char *setfunc;
			char *nextfunc;

			/* check if we need to forward declare our types
			 */
			testfunc = default_testfunc(tree);
			getfunc = default_getfunc(tree);
			setfunc = default_setfunc(tree),
			nextfunc = default_nextfunc(tree);

			if(accumulate_check(testfunc) == 0) {
				fprintf(fout, "extern int %s();\n", testfunc);
				accumulate_add(testfunc);
				}

			if(accumulate_check(getfunc) == 0) {
				fprintf(fout, "extern int %s();\n", getfunc);
				accumulate_add(getfunc);
				}

			if(accumulate_check(setfunc) == 0) {
				fprintf(fout, "extern int %s();\n", setfunc);
				accumulate_add(setfunc);
				}

			if(accumulate_check(nextfunc) == 0) {
				fprintf(fout, "extern int %s();\n", nextfunc);
				accumulate_add(nextfunc);
				}

			fprintf(fout, "STATIC\n");
			if(use_leafm) {
				fprintf(fout, "MIBLEAF_T\t%s_leaf = LEAFM(\"%s\", %s,\n",
					tree->name, tree->name, resolve_type(tree));
				fprintf(fout, "\t\t\t%s, %s,\n", tree->access,
					testfunc);

				fprintf(fout, "\t\t\t%s, %s, %s,\n",
					getfunc, setfunc, nextfunc);

				fprintf(fout, "\t\t\t%s,\n", default_cookie(tree));
				fprintf(fout, "\t\t\t%s, %s, %s);\n",
					default_locator(tree),
					default_view_mask(tree),
					default_write_mask(tree));

				}
			else {
				fprintf(fout, "MIBLEAF_T\t%s_leaf = LEAF(\"%s\", %s,\n",
					tree->name, tree->name, resolve_type(tree));
				fprintf(fout, "\t\t\t%s, %s,\n", tree->access,
					testfunc);

				fprintf(fout, "\t\t\t%s, %s, %s,\n",
					getfunc, setfunc, nextfunc);

				fprintf(fout, "\t\t\t%s);\n", default_cookie(tree));
				}

			}
	}

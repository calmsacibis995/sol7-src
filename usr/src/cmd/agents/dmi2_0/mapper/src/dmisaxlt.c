/* Copyright 10/07/96 Sun Microsystems, Inc. All Rights Reserved.
*/
#pragma ident  "@(#)dmisaxlt.c	1.7 96/10/07 Sun Microsystems"

/* Module Description *************************************************/
/*                                                                    */
/*  Name:  dmisaxlt.c                                                 */
/*                                                                    */
/*  Description:                                                      */
/*  This module contains functions to support DMI access.             */
/*                                                                    */
/*  Notes: This file contains the following functions:                */
/*                                        buildXlate(...)             */
/*                                        addToXlate(...)             */
/*                                        deleteFromXlate(...)        */
/*                                        findOidPrefix(...)          */
/*                                        freeXlate(...)              */
/*                                        buildOidList(...)           */
/*                                        createCompList(...)         */
/*                                        createGCPairs(...)          */
/*                                        getGCPairs(...)             */
/*                                        freeCompList(...)           */
/*                                        sortGCPairs(...)            */
/*                                                                    */
/* End Module Description *********************************************/
/*                                                                    */
/* Copyright **********************************************************/
/*                                                                    */
/* Copyright:                                                         */
/*   Licensed Materials - Property of IBM                             */
/*   This product contains "Restricted Materials of IBM"              */
/*   xxxx-xxx (C) Copyright IBM Corp. 1994.                           */
/*   All rights reserved.                                             */
/*   US Government Users Restricted Rights -                          */
/*   Use, duplication or disclosure restricted by GSA ADP Schedule    */
/*   Contract with IBM Corp.                                          */
/*   See IBM Copyright Instructions.                                  */
/*                                                                    */
/* End Copyright ******************************************************/
/*                                                                    */
/*                                                                    */
/* Change Log *********************************************************/
/*                                                                    */
/*  Flag  Reason    Date      Userid    Description                   */
/*  ----  --------  --------  --------  -----------                   */
/*                  941214    LAUBLI    New module                    */
/*                  950120    LAUBLI    Fix free of dmi buffers       */
/*                  950131    LAUBLI    Initialize ptr in right place */
/*                                                                    */
/* End Change Log *****************************************************/

#include "dmisa.h"     /* global header file for DMI Sub-agent        */
#include "dmisamap.h"  /* header file for collecting .MAP files from disk*/

typedef struct _compentry{
   struct _compentry *pNext;
   ULONG   iCompId;
   char    *pCompName;
}CompList_t;

extern char logbuffer[];
#ifdef DMISA_TRACE
extern unsigned char logbuffer[];
#endif

static int  buildOidList(OidPrefix_t **ppXlateList);
static int  createCompList(CompList_t **ppCompList);
static int  createGCPairs(OidPrefix_t *XlateList, CompList_t *pCompList);
static int  getGCPairs(GCPair_t **ppGCPairs, int compid);  /* GC = Group/Component*/
static void freeCompList(CompList_t *pCompList);
static void sortGCPairs(OidPrefix_t *XlateList);  /* GC = Group/Component*/

/**********************************************************************/
/* Function: BuildXlate()     - Build the XlateList structure         */
/*                                                                    */
/* Input parameters:                                                  */
/*   ptr. to .MAP list (compilation of .MAP files generated by        */
/*                      MIF2MIB, ordered by OID)                      */
/*                                                                    */
/* Output parameters:                                                 */
/*   ptr. to XlateList structure                                      */
/*                                                                    */
/* Description:                                                       */
/* o Get DMI to SNMP mapping information from .MAP files.             */
/* o Perform ListComponent on all components, temporarily saving      */
/*   each component ID and associated component name until XlateList  */
/*   has been created.                                                */
/* o Create XlateList group/component pairs, appending a key          */
/*   attribute ID list to each pair if keys exist for the group.      */
/* o Order XlateList pairs behind their respective OIDs.              */
/*                                                                    */
/* XlateList Structure:                                               */
/*                                                                    */
/*  pNextOidPre  --> pNext    --> pNext    -->  ...  --> pNext   --|| */
/*  pNextGCPair      iGroupId     iGroupId               iGroupId     */
/*  pOidPrefix       iCompId      iCompId                iCompId      */
/*  iRegFlag         iKeyCount=2  iKeyCount=n            iKeyCount=0  */
/*  iCompNameCt=n     iKeyAttrId   iKeyAttrId                         */
/*   pCompName        iKeyAttrType iKeyAttrType                       */
/*   pCompName        iKeyAttrId   iKeyAttrId                         */
/*       .            iKeyAttrType iKeyAttrType                       */
/*       .                              .                             */
/*       .                              .                             */
/*   pCompName                          .                             */
/*       |                         iKeyAttrId                         */
/*       |                         iKeyAttrType                       */
/*       V                                                            */
/*  pNextOidPre  --> pNext    --> pNext    -->  ...  --> pNext   --|| */
/*  pNextGCPair      iGroupId     iGroupId               iGroupId     */
/*  pOidPrefix       iCompId      iCompId                iCompId      */
/*  iRegFlag         iKeyCount=1  iKeyCount=0            iKeyCount=0  */
/*  iCompNameCt=1     iKeyAttrId                                      */
/*   pCompName        iKeyAttrType                                    */
/*       |                                                            */
/*       V                                                            */
/*  pNextOidPre  --||                                                 */
/*  pNextGCPair                                                       */
/*  pOidPrefix                                                        */
/*  iRegFlag                                                          */
/*  iCompNameCt=1                                                     */
/*   pCompName                                                        */
/*       |                                                            */
/*       V                                                            */
/*       .                                                            */
/*       .                                                            */
/*       .                                                            */
/*       |                                                            */
/*       V                                                            */
/*  pNextOidPre  --> pNext    --> pNext    -->  ...  --> pNext   --|| */
/*  pNextGCPair      iGroupId     iGroupId               iGroupId     */
/*  pOidPrefix       iCompId      iCompId                iCompId      */
/*  iRegFlag         iKeyCount=0  iKeyCount=0            iKeyCount=0  */
/*  iCompNameCt=1                                                     */
/*   pCompName                                                        */
/*       |                                                            */
/*       =                                                            */
/*                                                                    */
/* Notes:                                                             */
/* 1. sOidPrefix is the OID registered with DPI.  When registered,    */
/*    iRegFlag is set, otherwise it is reset.                         */
/* 2. iCompNameCt and iKeyCount are set for example sake only.        */
/*    Following iKeyCount is a pair of integers per key.              */
/*    Following iCompNameCt are names of all components visible under */
/*    that OID prefix subtree.  A given component name may be listed  */
/*    under multiple OID prefixes.  An OID prefix may have no         */
/*    group/component structures attached to it, which occurs whenever*/
/*    none of the instantiated components match the component name(s) */
/*    listed with the prefix.                                         */
/* 3. Storage is allocated individually for each structure.           */
/* 4. Potential performance improvements                              */
/*    a) Append a list of all attribute ID values within a particular */
/*       group to its associated group/component structure(s),        */
/*       which would perform these accesses once rather than for      */
/*       each GetNext access.  This information would be collected    */
/*       via ListAttribute at initialization or component             */
/*       installation time.                                           */
/*    b) Add maxAttrId to each group/component structure to avoid     */
/*       a DMI access on GetNext operations to the last attribute     */
/*       of each group.  This information would be collected via      */
/*       ListAttribute at initialization or component installation    */
/*       time.                                                        */
/* 5.  XlateList points to a 3-dimensional structure of storage blocks*/
/*     allocated but not freed  by this function and its subfunctions.*/
/*     It must be freed by the caller (e.g, with a call to freeXlate).*/
/*                                                                    */
/* Reason codes: BUILD_XLATE_noError                                  */
/*               BUILD_OID_LIST_outOfMemory                           */
/*               CREATE_GC_PAIRS_dmiBroke                             */
/*               CREATE_GC_PAIRS_outOfMemory                          */
/*               GET_GC_PAIRS_dmiBroke                                */
/*               GET_GC_PAIRS_outOfMemory                             */
/**********************************************************************/
int buildXlate(OidPrefix_t **ppXlateList)
{
   CompList_t  *pCompList;
   int          rc;

   rc = buildOidList(ppXlateList);
   if (rc != BUILD_OID_LIST_noError) return rc;

   if (*ppXlateList != NULL) {

      rc = createCompList(&pCompList);
      if (rc != CREATE_COMP_LIST_noError) return rc;

      rc = createGCPairs(*ppXlateList, pCompList);  /* GC = Group/Component*/
      if (rc != CREATE_GC_PAIRS_noError) return rc;

      freeCompList(pCompList);

      sortGCPairs(*ppXlateList);  /* GC = Group/Component             */

   }

   return BUILD_XLATE_noError;
}

/**********************************************************************/
/* Function: addToXlate()   - Add a Component to XlateList structure  */
/*                                                                    */
/* Input parameters:                                                  */
/*   Component ID                                                     */
/*   Component Name                                                   */
/*   ptr. to XlateList structure                                      */
/*                                                                    */
/* Output parameters:                                                 */
/*                                                                    */
/* Description:                                                       */
/*                                                                    */
/* Notes:                                                             */
/*   1.  CompName parameter must be set to a valid string.            */
/*   2.  Storage to contain GCPairs is allocated but not freed        */
/*       by this function.  It must be freed by the caller.           */
/*       A copy of the GCPair list belonging to this new component    */
/*       has been added to each OID indicated in the .MAP files.      */
/*       (deleteFromXlate or freeXlate can be called to free it.)     */
/*                                                                    */
/* When Install (component installation) occurs:                      */
/*  a) Given the component ID and ComponentName,                      */
/*     issue ListFirstGroup and, as needed, ListNextGroup, to collect */
/*     all group IDs and any associated key information               */
/*     for the particular component.                                  */
/*  b) Allocate storage and assign values to each group/component     */
/*     structure.                                                     */
/*  c) Add group/component structures to the table.                   */
/*                                                                    */
/* Note: Currently, abort program execution when process runs out of  */
/*       memory.  In future, could , if at all possible.              */
/* Note: If, for any reason, the function fails, XlateList will be    */
/*       left in an unaltered state, if at all possible.              */
/*                                                                    */
/* Reason codes: ADD_XLATE_noError                                    */
/*               ADD_XLATE_outOfMemory                                */
/*               GET_GC_PAIRS_dmiBroke                                */
/*               GET_GC_PAIRS_outOfMemory                             */
/**********************************************************************/
int addToXlate(int compi, char *CompName, OidPrefix_t *xlatelist)
{
   OidPrefix_t *txlatelist;
   GCPair_t    *GCPairs, *gcpair, *oldpair, *newpair;
   GCPair_t    *prevnewpair, *newgcpairs;
   GCKey_t     *oldkey, *newkey;
   int          i, j, firstmatch, rc;
   char        **temp;


   firstmatch = DMISA_TRUE;  /* initialize                            */

   txlatelist = xlatelist;
   while (txlatelist != NULL) {  /* walk thru xlatelist OIDs one at a time*/
      temp = &(txlatelist->pCompName);  /* initialize                 */
      for (j=1; j <= txlatelist->iCompNameCt; j++, temp++) {
         if (!strcmp(*temp,CompName)) {
            if (firstmatch) {
               rc = getGCPairs(&GCPairs, compi);
               if (rc != GET_GC_PAIRS_noError) return rc;
               firstmatch = DMISA_FALSE;
               DMISA_TRACE_LOG1(LEVEL2, "Adding component %u to XlateList.", compi);
            } else { /* already executed getGCPairs for this component*/
               /* Copy these G/C pairs & tack onto this OID prefix    */
               oldpair = GCPairs;
               prevnewpair = NULL;             /* To squelch a compiler message*/
               while (oldpair != NULL) {
                  newpair     = malloc( sizeof(GCPair_t) +
                                 oldpair->iKeyCount * sizeof(GCKey_t));
                  if (!newpair) return ADD_XLATE_outOfMemory;
                  *newpair = *oldpair;
                  oldkey = (GCKey_t *)(oldpair + 1); /* set to key attributes*/
                  newkey = (GCKey_t *)(newpair + 1); /* set to key attributes*/
                  for (i=1; i <= oldpair->iKeyCount; i++, oldkey++, newkey++) {
                     *newkey = *oldkey;
                  }
                  if (oldpair == GCPairs) {  /* for first pair        */
                     newgcpairs = newpair;
                  } else {                   /* for subsequent pairs  */
                     prevnewpair->pNextGCPair = newpair; /* next TO pair*/
                  }
                  oldpair = oldpair->pNextGCPair;        /* next FROM pair*/
                  prevnewpair = newpair;
               }
               GCPairs = newgcpairs;  /* point current GC pair to new copy*/
            }
            /* Append these GC pairs to this OID prefix               */
            if (!(txlatelist->pNextGCPair)) { /* then no GC pairs on OID*/
               txlatelist->pNextGCPair = GCPairs;  /* make it the first*/
            } else {  /* already some GC pairs on this OID prefix     */
               gcpair = txlatelist->pNextGCPair;
               while (gcpair != NULL && gcpair->pNextGCPair != NULL) {
                  gcpair = gcpair->pNextGCPair;
               }  /* find last GC pair on this OID prefix             */
               gcpair->pNextGCPair = GCPairs;  /* append to last one  */
            }
         }
      }
      txlatelist = txlatelist->pNextOidPre;  /* step to next OID prefix*/
   }
   sortGCPairs(xlatelist);

   return ADD_XLATE_noError;
}

/**********************************************************************/
/* Function: deleteFromXlate()    - Delete a Component from XlateList */
/*                                                                    */
/* Input parameters:                                                  */
/*   Component ID                                                     */
/*   XlateList                                                        */
/*                                                                    */
/* Output parameters:                                                 */
/*   last oid prefix from which compid is deleted                     */
/*                                                                    */
/* Description:                                                       */
/* When component Uninstall occurs:                                   */
/*  a) Delete group/component structures for the identified           */
/*     component from the table.                                      */
/*  b) Free storage for each structure removed.                       */
/*                                                                    */
/* Reason codes: none                                                 */
/**********************************************************************/
OidPrefix_t *deleteFromXlate(int compi, OidPrefix_t *xlatelist)
{
   GCPair_t          *pthis, *plast;
   OidPrefix_t       *txlatelist, *last_xltlist;

   txlatelist = xlatelist;

   plast = NULL;                         /* To squelch a compiler message*/
   while (xlatelist != NULL) {
      pthis = xlatelist->pNextGCPair;
      while (pthis != NULL) {
         if (pthis->iCompId == compi) {  /* if this is a pair to be deleted*/
            DMISA_TRACE_LOG2(LEVEL2, "Deleting component %ul, group %ul from XlateList.", pthis->iCompId, pthis->iGroupId);
            if (pthis == xlatelist->pNextGCPair) {
               xlatelist->pNextGCPair = pthis->pNextGCPair;  /* drop out 1st pair*/
               free(pthis);              /* free the unneeded GC pair */
               pthis = xlatelist->pNextGCPair;
            } else {
               plast->pNextGCPair = pthis->pNextGCPair;  /* drop out this pair*/
               free(pthis);              /* free the unneeded GC pair */
               pthis = plast->pNextGCPair;
            }
            last_xltlist = xlatelist;
         } else {
            plast = pthis;
            pthis = pthis->pNextGCPair;
         }
      }
      xlatelist = xlatelist->pNextOidPre;
   }
   sortGCPairs(txlatelist);
   return (last_xltlist);
}

/**********************************************************************/
/* Function: deleteGroupFromXlate()- Delete a Group from XlateList    */
/*                                                                    */
/* Input parameters:                                                  */
/*   Group ID                                                         */
/*   XlateList                                                        */
/*                                                                    */
/* Output parameters:                                                 */
/*   void 							      */ 
/*                                                                    */
/* Description:                                                       */
/* When component Uninstall occurs:                                   */
/*  a) Delete group/component structures for the identified           */
/*     component from the table.                                      */
/*  b) Free storage for each structure removed.                       */
/*                                                                    */
/* Reason codes: none                                                 */
/**********************************************************************/
void deleteGroupFromXlate(int groupi , OidPrefix_t *xlatelist)
{
   GCPair_t          *pthis, *plast;
   OidPrefix_t       *txlatelist;

   txlatelist = xlatelist;

   plast = NULL;                         /* To squelch a compiler message*/
   while (xlatelist != NULL) {
      pthis = xlatelist->pNextGCPair;
      while (pthis != NULL) {
         if (pthis->iGroupId == groupi) {  /* if this is a pair to be deleted*/
            DMISA_TRACE_LOG2(LEVEL2, "Deleting component %ul, group %ul from Xlate List.", pthis->iCompId, pthis->iGroupId);
            if (pthis == xlatelist->pNextGCPair) {
               xlatelist->pNextGCPair = pthis->pNextGCPair;  /* drop out 1st pai r*/
               free(pthis);              /* free the unneeded GC pair */
               pthis = xlatelist->pNextGCPair;
            } else {
               plast->pNextGCPair = pthis->pNextGCPair;  /* drop out this pair*/
               free(pthis);              /* free the unneeded GC pair */
               pthis = plast->pNextGCPair;
            }
         } else {
            plast = pthis;
            pthis = pthis->pNextGCPair;
         }
      }
      xlatelist = xlatelist->pNextOidPre;
   }
   sortGCPairs(txlatelist);
}

/**********************************************************************/
/* Function: findOidPrefix()  - Find Component within XlateList struct*/
/*                                                                    */
/* Input parameters:                                                  */
/*   Component ID                                                     */
/*   ptr. to start of XlateList structure                             */
/*                                                                    */
/* Output parameters:                                                 */
/*   char ptr. to OidPrefix or NULL if none exists.                   */
/*                                                                    */
/* Description:                                                       */
/* Given a component identifier and the starting point to XlateList,  */
/* find the first OID prefix which contains the component ID.         */
/*                                                                    */
/* Reason codes: none                                                 */
/**********************************************************************/
char *findOidPrefix(int compi, OidPrefix_t *xlatelist)
{
   GCPair_t *pthis;

   while (xlatelist != NULL) {  /* walk thru xlatelist OIDs one at a time*/
      pthis = xlatelist->pNextGCPair;
      while (pthis != NULL) {
         if (pthis->iCompId == compi) {  /* if this is a pair to be deleted*/
            return xlatelist->pOidPrefix;
         }
         pthis = pthis->pNextGCPair;
      }
      xlatelist = xlatelist->pNextOidPre;
   }

/*   return (char *)NULL;                                             */
     return (0);
}


/**********************************************************************/
/* Function: FreeXlate()   - Free the XlateList structure             */
/*                                                                    */
/* Input parameters:                                                  */
/*   ptr. to XlateList structure                                      */
/*                                                                    */
/* Output parameters:  none                                           */
/*                                                                    */
/* Description:                                                       */
/* Free all structures within XlateList (includes prefixes & GC pairs)*/
/*                                                                    */
/**********************************************************************/
void freeXlate(void)
{
   GCPair_t    *pnext, *pthis;
   OidPrefix_t *pnextoid;
   char        **temp;
   int         i;

   if (XlateList != NULL) {
      do {
         if (NULL != (pthis = XlateList->pNextGCPair)) {
            do {
               pnext = pthis->pNextGCPair;
               free(pthis);             /* Free GC pair               */
               pthis  = pnext;
            } while (pthis != NULL);
         }
         free(XlateList->pOidPrefix);   /* Free prefix - allocated by DMISAMAP*/
         temp = &(XlateList->pCompName);
         for (i=1; i <= XlateList->iCompNameCt; i++, temp++) {
            free(*temp);                /* Free component name        */
         }
         pnextoid = XlateList->pNextOidPre;
         free(XlateList);               /* Free prefix block          */
         XlateList = pnextoid;
      } while (XlateList != NULL);
   }
   DMISA_TRACE_LOG(LEVEL2, "Translation table memory has been freed.\n");
}

/**********************************************************************/
/* Function: buildOidList() - Build the top-most level of XlateList   */
/*                            structure                               */
/*                                                                    */
/* Create list of OID prefixes to be registered with the SNMP agent   */
/*                                                                    */
/* Notes:                                                             */
/*   1.  This function and its subfunction allocate but do not free   */
/*       the following storage blocks:                                */
/*              - a list of OidPrefix_t structures                    */
/*              - a string containing the OID for each OidPrefix_t    */
/*                structure (duplicates are freed)                    */
/*              - a list of component names attached to each of the   */
/*                OidPrefix_t structures                              */
/*       The caller must ensure they are freed. (E.g, use freeXlate.) */
/*                                                                    */
/* Reason codes: BUILD_OID_LIST_noError                               */
/*               BUILD_OID_LIST_outOfMemory                           */
/**********************************************************************/
static int buildOidList(OidPrefix_t **ppXlateList)
{
   struct _line *maplist, *oldmaplist;
   OidPrefix_t  *thisoid, *prevoid, *secondlastoid;
   struct _oidprefix dummy;
   char         *prevmapoid;   /* points to maplist data */
   char         **name, dummystring[] = "0";
   int          i, rc, addname, cnamespace;

   *ppXlateList = NULL;  /* initialize                                */

   rc = buildMap(&maplist);  /* collect data from .MAP files          */
   if (rc) {
      DMISA_TRACE_LOG(LEVEL1, "Error in extracting translation list from .MAP files.");
      return rc;
   }

   /* set up OID list                                                 */
   if (maplist != NULL) {
      prevmapoid    = dummystring;  /* initialize                     */
 /*   prevcompname  = NULL;  // initialize                            */
      prevoid       = NULL;  /* initialize                            */
      secondlastoid = NULL;  /* initialize                            */
      do {
         if ( strcmp(prevmapoid,maplist->oid) ) {  /* if OIDs not equal,*/
                                                   /* add OID prefix to XlateList*/
            thisoid = malloc(sizeof(OidPrefix_t));
            if (!thisoid) return BUILD_OID_LIST_outOfMemory;
            thisoid->pNextOidPre = NULL;
            thisoid->pNextGCPair = NULL;
            thisoid->pOidPrefix  = maplist->oid;
            thisoid->iRegFlag    = DMISA_FALSE;
            thisoid->iCompNameCt = 1;
            thisoid->pCompName   = maplist->compo_name;
            thisoid->sequentialKeys = maplist->sequentialKeys;
            if (*ppXlateList == NULL ) {
               *ppXlateList = thisoid;
            } else {
               prevoid->pNextOidPre = thisoid;
            }
            secondlastoid = prevoid;
         } else { /* OID prefixes are equal, so if component names not equal,*/
                  /* replace entry with another appended component name*/
                  /* (so we malloc the updated and free the old copy - could have used realloc)*/
            addname = DMISA_TRUE;
            name = &(prevoid->pCompName);  /* initialize              */
            for (i=1; i <= prevoid->iCompNameCt; i++, name++) {
               if (strcmp(*name, maplist->compo_name) == 0) {
                  addname = DMISA_FALSE;
               }
            }
            if (addname == DMISA_TRUE) {
               cnamespace = sizeof(dummy.pCompName) *
                            prevoid->iCompNameCt; /* size of space for old ptrs*/
               thisoid = malloc( sizeof(OidPrefix_t) + cnamespace +
                                 sizeof(dummy.pCompName));
               if (!thisoid) return BUILD_OID_LIST_outOfMemory;
               thisoid->pNextOidPre = NULL;
               thisoid->pNextGCPair = NULL;
               thisoid->pOidPrefix  = prevoid->pOidPrefix;
               thisoid->iRegFlag    = DMISA_FALSE;
               thisoid->sequentialKeys = prevoid->sequentialKeys;
               memcpy(&(thisoid->pCompName),&(prevoid->pCompName),
                      cnamespace);  /* Copy existing component names  */
               memcpy( (((char *)&(thisoid->pCompName)) + cnamespace),
                      &(maplist->compo_name),sizeof(dummy.pCompName));
                      /* Add new component name                       */
               thisoid->iCompNameCt  = prevoid->iCompNameCt + 1;
               if ( secondlastoid != NULL ) { /* remove old struct.from list*/
                  secondlastoid->pNextOidPre = thisoid;
               }
               if (*ppXlateList == prevoid) {
                  *ppXlateList = thisoid; /* remove old structure from list*/
               }
               free(prevoid);
            } else {
               free(maplist->compo_name);  /* Allocated in DMISAMAP.C */
            }
            free(maplist->oid);            /* Allocated in DMISAMAP.C */

         }
         prevoid = thisoid;  /* save XlateList tail                   */
         prevmapoid = prevoid->pOidPrefix;
         oldmaplist = maplist;
         maplist = maplist->next;  /* save new head of map list       */
         free(oldmaplist->key); /* Allocated in DMISAMAP.C            */
         free(oldmaplist);      /* Allocated in DMISAMAP.C            */
      } while ( maplist != NULL );
   }
   return BUILD_OID_LIST_noError;
}

/**********************************************************************/
/* Function: createCompList()  - Create a list of IDs and names for   */
/*                               all installed components             */
/*                                                                    */
/* Notes:                                                             */
/*   1.  *ppCompList points to a list of CompList_t structures        */
/*       allocated but not freed by this function.  They must be      */
/*       freed by the caller (e.g, by calling freeCompList)           */
/*   2.  A string for each CompList_t structure is allocated but not  */
/*       freed by this function.  These must be freed by the caller   */
/*       (e.g, by calling freeCompList).                              */
/*                                                                    */
/* Reason codes: CREATE_COMP_LIST_noError                             */
/*               CREATE_COMP_LIST_dmiBroke                            */
/*               CREATE_COMP_LIST_outOfMemory                         */
/*               ISSUE_LIST_COMP_outOfMemory                          */
/**********************************************************************/
static int createCompList(CompList_t **ppCompList)
{
   DmiListComponentsOUT   *listcompout=NULL;
   DmiComponentInfo_t     *compinfo;
   CompList_t             *tcomplist, *prevcomplist;
   DMI_STRING             *work;
   int         cmd = DMISA_FIRST;
   int         i, rc, dmistat, dummy;
   ULONG       reqcompid = 0; /* component ID from request block      */

   *ppCompList = NULL;     /* Initialize                              */
   prevcomplist = NULL;                /* To squelch a compiler warning*/
   dummy = 0;              /* To squelch a compiler warning           */


      rc = issueListComp(&listcompout,
                         dummy,
                         reqcompid,
                         cmd,
                         0);  /*All the components */
      if (rc != ISSUE_LIST_COMP_noError) {
         if (listcompout)
             free_listcompout(listcompout);

         if (rc == ISSUE_LIST_COMP_failed)
            return CREATE_COMP_LIST_dmiBroke;
         else return rc;
      }
      compinfo = listcompout->reply->list.list_val;
      for (i = 1; i <= listcompout->reply->list.list_len; i++, compinfo++) {
            /* Add each component to the list                         */
            tcomplist    = malloc(sizeof(CompList_t));
            if (!tcomplist) return CREATE_COMP_LIST_outOfMemory;
            tcomplist->pNext   = NULL;
            tcomplist->iCompId = compinfo->id;
            tcomplist->pCompName = calloc(1, compinfo->name->body.body_len+1);
               if (!tcomplist->pCompName) return CREATE_COMP_LIST_outOfMemory;
                    /* could also check that length is not more than 256*/
               strncpy(tcomplist->pCompName,
               compinfo->name->body.body_val ,
               compinfo->name->body.body_len);
               if (cmd == DMISA_FIRST) {
                  *ppCompList = tcomplist; /* first component in CompList*/
                  cmd          = DMISA_NEXT;
               } else {
                  prevcomplist->pNext = tcomplist;
               }
               prevcomplist = tcomplist;
         }
         /*reqcompid = tcomplist->iCompId;*/ /* Start next S.L. retrieval here*/
      if (listcompout) {
         free_listcompout(listcompout);
      }

   return CREATE_COMP_LIST_noError;
}

/**********************************************************************/
/* Function: createGCPairs()  - Create all Group/Component pairs from */
/*                              the MIF database and link them to the */
/*                              appropriate OID prefixes in XlateList */
/*                              structure.                            */
/*                                                                    */
/* Notes:                                                             */
/*   1.  This function or its subfunction allocates but does not free */
/*       storage to contain GCPair structures.  They must be freed by */
/*       the caller (e.g, by calling deleteFromXlate or freeXlate).   */
/*                                                                    */
/* Reason codes: CREATE_GC_PAIRS_noError                              */
/*               CREATE_GC_PAIRS_dmiBroke                             */
/*               CREATE_GC_PAIRS_outOfMemory                          */
/*               GET_GC_PAIRS_dmiBroke                                */
/*               GET_GC_PAIRS_outOfMemory                             */
/**********************************************************************/
static int createGCPairs(OidPrefix_t *pXlateList, CompList_t *pCompList)
{
   OidPrefix_t *tXlateList;
   GCPair_t    *GCPairs, *gcpair, *oldpair, *newpair;
   GCPair_t    *prevnewpair, *newgcpairs;
   GCKey_t     *oldkey, *newkey;
   int         i, j, firstmatch, rc;
   char        **name;

   while ( pCompList != NULL &&
          pXlateList != NULL) {  /* walk thru CompList one component at a time*/
      tXlateList = pXlateList;  /* initialize                         */
      firstmatch = DMISA_TRUE;  /* initialize                         */
      while (tXlateList != NULL ) { /* walk thru XlateList OIDs one at a time*/
         name = &(tXlateList->pCompName);  /* initialize              */
         for (j=1; j <= tXlateList->iCompNameCt; j++, name++) {
            if (!strcmp(*name, pCompList->pCompName)) {
               if (firstmatch) {
                  rc = getGCPairs(&GCPairs, pCompList->iCompId);
                  if (rc != GET_GC_PAIRS_noError) return rc;
                  firstmatch = DMISA_FALSE;
               } else { /* already executed getGCPairs for this component*/
                  /* Copy these G/C pairs & tack onto this OID prefix */
                  oldpair = GCPairs;
                  prevnewpair = NULL;          /* To squelch a compiler warning*/
                  while (oldpair != NULL) {
                     newpair = malloc(sizeof(GCPair_t) +
                                      oldpair->iKeyCount * sizeof(GCKey_t));
                     if (!newpair) return CREATE_GC_PAIRS_outOfMemory;
                     *newpair = *oldpair;
                     oldkey = (GCKey_t *)(oldpair + 1);  /* set to key attribute info*/
                     newkey = (GCKey_t *)(newpair + 1);  /* set to key attribute info*/
                     for (i=1; i <= oldpair->iKeyCount; i++, oldkey++, newkey++) {
                        *newkey = *oldkey;
                     }
                     if (oldpair == GCPairs) {  /* for first pair     */
                        newgcpairs = newpair;
                     } else {                   /* for subsequent pairs*/
                        prevnewpair->pNextGCPair = newpair; /* next TO pair*/
                     }
                     oldpair = oldpair->pNextGCPair;        /* next FROM pair*/
                     prevnewpair = newpair;
                  }
                  GCPairs = newgcpairs;  /* point current GC pair to new copy*/
               }
               /* Append these GC pairs to this OID prefix            */
               if (!(tXlateList->pNextGCPair)) { /* then no GC pairs on OID*/
                  tXlateList->pNextGCPair = GCPairs;  /* make it the first*/
               } else {  /* already some GC pairs on this OID prefix  */
                  gcpair = tXlateList->pNextGCPair;
                  while (gcpair != NULL && gcpair->pNextGCPair != NULL) {
                     gcpair = gcpair->pNextGCPair;
                  }  /* find last GC pair on this OID prefix          */
                  gcpair->pNextGCPair = GCPairs;  /* append to last one*/
               }
            }
         }
         tXlateList = tXlateList->pNextOidPre;  /* step to next OID prefix*/
      } /* endwhile */

      pCompList = pCompList->pNext;  /* step to next entry            */
   } /* endwhile */

   return CREATE_GC_PAIRS_noError;
}

/**********************************************************************/
/* Function: getGCPairs()  - Extract from the MIF database the list of*/
/*                           Group/Component pairs for the given      */
/*                           component ID.                            */
/*                                                                    */
/* Reason codes: GET_GC_PAIRS_noError                                 */
/*               GET_GC_PAIRS_dmiBroke                                */
/*               GET_GC_PAIRS_outOfMemory                             */
/*               ISSUE_LIST_GROUP_outOfMemory                         */
/**********************************************************************/
static int getGCPairs(GCPair_t **ppGCPairs, int compid)
{
   GCPair_t           *tgcpair, *prevgcpair;
   unsigned long      keytype;
   unsigned int       keycount=0;
   DmiId_t            *pkey;
   GCKey_t            *pkeyto;
   ULONG              gid,groupid = 0;     /* component ID requested from DMI*/
   int                rc, cmd = DMISA_FIRST;
   int                i, j, dmistat;
   DmiListGroupsOUT   *listgroupout=NULL;
   DmiGroupInfo_t     *groupinfo, *groupinfo1;
   int curpos;

   *ppGCPairs = NULL;      /* initialize                              */
   prevgcpair = NULL;     /* To squelch a compiler warning  -  moved 950131.gwl */

      rc = issueListGroup(&listgroupout,
              compid,
              groupid,
              cmd,
              0);   /*All the groups */
      if (rc != ISSUE_LIST_GROUP_noError) {
         if (listgroupout) 
            free_listgroupout(listgroupout);    
         
         if (rc == ISSUE_LIST_GROUP_failed)
            return GET_GC_PAIRS_dmiBroke;
         else return rc;
      } else {
         groupinfo = listgroupout->reply->list.list_val;
         /*To fill the keylist for tables */
         for (i = 1; i <= listgroupout->reply->list.list_len;     
              i++, groupinfo++) {
             if (groupinfo->id == 0) {
                groupinfo1 = groupinfo;
                curpos=i;
                curpos++;groupinfo1++;
                while(curpos <= listgroupout->reply->list.list_len) {
                    if (!strncmp(groupinfo->className->body.body_val,
                                groupinfo1->className->body.body_val,
                                groupinfo->className->body.body_len)) {
                        if (!groupinfo1->keyList) {
                        groupinfo1->keyList = (DmiAttributeIds_t *)
                                        calloc(1, sizeof(DmiAttributeIds_t));
                        groupinfo1->keyList->list.list_len =
                        groupinfo->keyList->list.list_len;
 
                        groupinfo1->keyList->list.list_val = (DmiId_t *)
                  calloc(1, sizeof(DmiId_t)*groupinfo->keyList->list.list_len); 
                        memcpy((char *)groupinfo1->keyList->list.list_val,
                               (char *)groupinfo->keyList->list.list_val,
                         sizeof(DmiId_t)*groupinfo->keyList->list.list_len);
                        }
                        break;
                    }
                    groupinfo1++;
                    curpos++;
                }
                
             }
         }

         groupinfo = listgroupout->reply->list.list_val;
         for (i = 1; i <= listgroupout->reply->list.list_len;
              i++, groupinfo++) {
            /* add each group/component pair to the list              */
            if (groupinfo->id == 0)
                 continue;
            if (groupinfo->keyList)
               keycount = groupinfo->keyList->list.list_len;
            else
               keycount = 0;
            tgcpair = malloc(sizeof(GCPair_t) + keycount * sizeof(GCKey_t));
            if (!tgcpair) return GET_GC_PAIRS_outOfMemory;
            tgcpair->pNextGCPair = NULL;
            tgcpair->iGroupId    = groupinfo->id;
            tgcpair->iCompId     = compid;
            tgcpair->iKeyCount   = keycount;

           if (groupinfo->keyList) {          
            pkey = groupinfo->keyList->list.list_val; 
            pkeyto = (GCKey_t *)(tgcpair + 1);  /* set to key attribute info*/
          for (j=1; j<=groupinfo->keyList->list.list_len; j++, pkeyto++, pkey++) {
                  /* move key data from confirm buffer to XlateList   */
                  pkeyto->iKeyAttrId =  *pkey;
                   
                  if (findAttributeType(&keytype, compid,groupinfo->id, *pkey) ==
                      FIND_ATTRIBUTE_TYPE_noError)
                    pkeyto->iKeyAttrType = keytype;
                  else
                      return GET_GC_PAIRS_dmiBroke;
               }
           }
               if (cmd == DMISA_FIRST) {
                  *ppGCPairs = tgcpair; /* first GC pair in this component*/
                  cmd    = DMISA_NEXT;
               } else {
                  prevgcpair->pNextGCPair = tgcpair;  /* if not 1st pair,*/
                                           /* tack it on the preceeding one*/
               }
               prevgcpair = tgcpair;
         }
         /*groupid = tgcpair->idGroupId;*/ /* get more groups starting at this group ID*/
      }
      if (listgroupout) 
         free_listgroupout(listgroupout);

   return GET_GC_PAIRS_noError;
}

/**********************************************************************/
/* Function: freeCompList() - Free the list of installed component IDs*/
/*                            and names.                              */
/*                                                                    */
/* Reason codes: none                                                 */
/**********************************************************************/
static void freeCompList(CompList_t *pCompList)
{
   CompList_t *pnext;

   if (pCompList != NULL) {
      do {
         pnext = pCompList->pNext;
         free(pCompList->pCompName);
         free(pCompList);
         pCompList = pnext;
      } while (pCompList != NULL);
   }
}

/**********************************************************************/
/* Function: sortGCPairs() - Sort Group/Component pairs from lowest to*/
/*                           highest, by group, then by component.    */
/*                                                                    */
/*      Performance improvement: Currently this function swaps A & B. */
/*                       Would be more efficient to insert B before A.*/
/*                                                                    */
/* Reason codes: none                                                 */
/**********************************************************************/
static void sortGCPairs(OidPrefix_t *xlatelist)
{
   GCPair_t *A, *prevA = NULL;
   GCPair_t *B, *prevB, *temp, *tempprev;
#ifdef DMISA_TRACE
   OidPrefix_t *t;
   char     s[20];
   int      i;

   t = xlatelist;
#endif

   while (xlatelist != NULL) {
      for (A = xlatelist->pNextGCPair; A != NULL; A = A->pNextGCPair) {
         prevB = A; /* as we enter next loop, B immediately follows A */
         for (B = A->pNextGCPair; B != NULL;
                       prevB = B, B = B->pNextGCPair) {
            if (A->iGroupId > B->iGroupId ||
                (A->iGroupId == B->iGroupId &&
                A->iCompId > B->iCompId) ) {
               /* Insert structure B before structure A in linked list*/
               if (A->pNextGCPair == B) { /* if B directly follows A  */
                  temp = A;
               } else {
                  temp = A->pNextGCPair;
               }
               tempprev = prevB->pNextGCPair;
               A->pNextGCPair = B->pNextGCPair; /* swap ptrs from A and B*/
               B->pNextGCPair = temp;
               if (prevA) {              /* swap ptrs to A and B      */
                  if (A != B->pNextGCPair) {  /* if B doesn't directly follow A*/
                     prevB->pNextGCPair = prevA->pNextGCPair;
                  }
                  prevA->pNextGCPair = tempprev;
               } else {
                  prevB->pNextGCPair = xlatelist->pNextGCPair;
                  xlatelist->pNextGCPair = tempprev;
               }
               temp = B;  /* swap A and B                             */
               B = A;
               A = temp;
            }
         }
         if (prevA) {
            prevA = A;
         } else {
            prevA = xlatelist->pNextGCPair;
         }
      }
      xlatelist = xlatelist->pNextOidPre;
   }

#ifdef DMISA_TRACE
   /* Trace XlateList                                                 */
   while (t != NULL) {
      logbuffer[0] = '\0';
      strncat(logbuffer, t->pOidPrefix, strlen(t->pOidPrefix));
      temp = t->pNextGCPair;
      while (temp != NULL) {
         strncat(logbuffer, "--",2);
         pitoa(temp->iGroupId, s);
         strncat(logbuffer, s, strlen(s));
         strncat(logbuffer, ",", 1);
         pitoa(temp->iCompId, s);
         strncat(logbuffer, s, strlen(s));
         temp = temp->pNextGCPair;
         if (strlen(logbuffer) > LOG_BUF_LEN - 12) {  /* Dump partial list.*/
                 /* The 12 is to leave some play at end of line    */
            DMISA_TRACE_LOGBUF(LEVEL2);
            logbuffer[0] = '\0';  /* Blank out the buffer          */
         }
      }
      DMISA_TRACE_LOGBUF(LEVEL2);
      for (i=0; i < t->iCompNameCt;i++) {
         strncpy(logbuffer, *(&(t->pCompName) + i), LOG_BUF_LEN);
         DMISA_TRACE_LOGBUF(LEVEL2);
      }
      t = t->pNextOidPre;
   }
#endif
}


/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "mi_indicate.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

DmiErrorStatus_t *
_dmideliverevent_0x1(DmiDeliverEventIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiDeliverEvent,
		(xdrproc_t) xdr_DmiDeliverEventIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmicomponentadded_0x1(DmiComponentAddedIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiComponentAdded,
		(xdrproc_t) xdr_DmiComponentAddedIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmicomponentdeleted_0x1(DmiComponentDeletedIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiComponentDeleted,
		(xdrproc_t) xdr_DmiComponentDeletedIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmilanguageadded_0x1(DmiLanguageAddedIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiLanguageAdded,
		(xdrproc_t) xdr_DmiLanguageAddedIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmilanguagedeleted_0x1(DmiLanguageDeletedIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiLanguageDeleted,
		(xdrproc_t) xdr_DmiLanguageDeletedIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmigroupadded_0x1(DmiGroupAddedIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiGroupAdded,
		(xdrproc_t) xdr_DmiGroupAddedIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmigroupdeleted_0x1(DmiGroupDeletedIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiGroupDeleted,
		(xdrproc_t) xdr_DmiGroupDeletedIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

DmiErrorStatus_t *
_dmisubscriptionnotice_0x1(DmiSubscriptionNoticeIN *argp, CLIENT *clnt)
{
	static DmiErrorStatus_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, _DmiSubscriptionNotice,
		(xdrproc_t) xdr_DmiSubscriptionNoticeIN, (caddr_t) argp,
		(xdrproc_t) xdr_DmiErrorStatus_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

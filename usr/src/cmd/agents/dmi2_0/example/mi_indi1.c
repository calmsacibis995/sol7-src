/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

/*DMI specific includes */
#include <server.h>
#include <dmi_error.hh>
#include <api.hh>
#include <miapi.hh>

#include "mi_indicate.h"
#include <stdio.h>
#include <stdlib.h> /* getenv, exit */
#include <rpc/pmap_clnt.h> /* for pmap_unset */
#include <string.h> /* strcmp */
#include <signal.h>
#ifdef __cplusplus
#include <sysent.h> /* getdtablesize, open */
#endif /* __cplusplus */
#include <unistd.h> /* setsid */
#include <sys/types.h>
#include <memory.h>
#include <stropts.h>
#include <netconfig.h>
#include <sys/resource.h> /* rlimit */
#include <syslog.h>

#ifndef SIG_PF
#define	SIG_PF void(*)(int)
#endif

#ifdef DEBUG
#define	RPC_SVC_FG
#endif

#define	_RPCSVC_CLOSEDOWN 120
static int _rpcpmstart;		/* Started by a port monitor ? */

/* States a server can be in wrt request */

#define	_IDLE 0
#define	_SERVED 1

static int _rpcsvcstate = _IDLE;	/* Set when a request is serviced */
static int _rpcsvccount = 0;		/* Number of requests being serviced */

typedef struct {
char *rpctype;
char *transport_type;
char *subscriber_addr;
int   subscriber_id;
DmiTimestamp_t  *warn_time;  /*Subscription Warning Notice Time Stamp */
DmiTimestamp_t  *exp_time;   /*Subscription Expiration Notice Time Stamp*/
int   failure_threshold;
}SubscriptionIN;

typedef struct {
char *rpctype;
char *transport_type;
char *subscriber_addr;
int   subscriber_id;
int   componentid_filter;
char *groupclass_filter;
int   severity_filter;
}FilterInfoIN;

extern int sp_indication_subscribe(SubscriptionIN  *subscribe_in);
extern int set_event_filter(FilterInfoIN *filter_in);

SubscriptionIN   subscribe_in;
FilterInfoIN     filter_in;
char             hostname[256];
char             subscriber_address[500];
char             SP_hostname[256];
DmiRpcHandle     dmi_rpchandle;
DmiRegisterIN    regin;
DmiRegisterOUT   regout;
ConnectIN        connectin;
DmiRegisterIN    regin;
DmiRegisterOUT   regout;


static
void _msgout(char* msg)
{
#ifdef RPC_SVC_FG
	if (_rpcpmstart)
		syslog(LOG_ERR, msg);
	else
		(void) fprintf(stderr, "%s\n", msg);
#else
	syslog(LOG_ERR, msg);
#endif
}

static void
closedown(int sig)
{
	if (_rpcsvcstate == _IDLE && _rpcsvccount == 0) {
		extern fd_set svc_fdset;
		static int size;
		int i, openfd;
		struct t_info tinfo;

		if (!t_getinfo(0, &tinfo) && (tinfo.servtype == T_CLTS))
			exit(0);
		if (size == 0) {
			struct rlimit rl;

			rl.rlim_max = 0;
			getrlimit(RLIMIT_NOFILE, &rl);
			if ((size = rl.rlim_max) == 0) {
				return;
			}
		}
		for (i = 0, openfd = 0; i < size && openfd < 2; i++)
			if (FD_ISSET(i, &svc_fdset))
				openfd++;
		if (openfd <= 1)
			exit(0);
	} else
		_rpcsvcstate = _IDLE;

	(void) signal(SIGALRM, (SIG_PF) closedown);
	(void) alarm(_RPCSVC_CLOSEDOWN/2);
}

static void
dmi2_client_0x1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		DmiDeliverEventIN _dmideliverevent_0x1_arg;
		DmiComponentAddedIN _dmicomponentadded_0x1_arg;
		DmiComponentDeletedIN _dmicomponentdeleted_0x1_arg;
		DmiLanguageAddedIN _dmilanguageadded_0x1_arg;
		DmiLanguageDeletedIN _dmilanguagedeleted_0x1_arg;
		DmiGroupAddedIN _dmigroupadded_0x1_arg;
		DmiGroupDeletedIN _dmigroupdeleted_0x1_arg;
		DmiSubscriptionNoticeIN _dmisubscriptionnotice_0x1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	_rpcsvccount++;
	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply(transp,
			(xdrproc_t) xdr_void, (char *)NULL);
		_rpcsvccount--;
		_rpcsvcstate = _SERVED;
		return;

	case _DmiDeliverEvent:
		_xdr_argument = (xdrproc_t) xdr_DmiDeliverEventIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmideliverevent_0x1_svc;
		break;

	case _DmiComponentAdded:
		_xdr_argument = (xdrproc_t) xdr_DmiComponentAddedIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmicomponentadded_0x1_svc;
		break;

	case _DmiComponentDeleted:
		_xdr_argument = (xdrproc_t) xdr_DmiComponentDeletedIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmicomponentdeleted_0x1_svc;
		break;

	case _DmiLanguageAdded:
		_xdr_argument = (xdrproc_t) xdr_DmiLanguageAddedIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmilanguageadded_0x1_svc;
		break;

	case _DmiLanguageDeleted:
		_xdr_argument = (xdrproc_t) xdr_DmiLanguageDeletedIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmilanguagedeleted_0x1_svc;
		break;

	case _DmiGroupAdded:
		_xdr_argument = (xdrproc_t) xdr_DmiGroupAddedIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmigroupadded_0x1_svc;
		break;

	case _DmiGroupDeleted:
		_xdr_argument = (xdrproc_t) xdr_DmiGroupDeletedIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmigroupdeleted_0x1_svc;
		break;

	case _DmiSubscriptionNotice:
		_xdr_argument = (xdrproc_t) xdr_DmiSubscriptionNoticeIN;
		_xdr_result = (xdrproc_t) xdr_DmiErrorStatus_t;
		local = (char *(*)(char *, struct svc_req *)) _dmisubscriptionnotice_0x1_svc;
		break;

	default:
		svcerr_noproc(transp);
		_rpcsvccount--;
		_rpcsvcstate = _SERVED;
		return;
	}
	(void) memset((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs(transp, _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode(transp);
		_rpcsvccount--;
		_rpcsvcstate = _SERVED;
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, _xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, _xdr_argument, (caddr_t) &argument)) {
		_msgout("unable to free arguments");
		exit(1);
	}
	_rpcsvccount--;
	_rpcsvcstate = _SERVED;
	return;
}

static void usage(char *cmd_p)
{
   printf("\nUsage: %s -s SP hostname [-h|-?]\n",cmd_p);
   printf("             SP hostname is host, where DMI service provider\n"
);
   printf("             is running.\n");
   printf("             h or ? for command line usage\n");
   exit(1);
}

main(int argc, char *argv[])
{
	pid_t pid;
	int i, opt;
        char *cmd_p;
        extern char *optarg;
        extern int   optind;

        if (argc > 0) {
             cmd_p = argv[0];
        }
        while((opt = getopt(argc, argv, "s:h?")) != EOF) {
          switch(opt) {
            case 's':
                      strcpy(SP_hostname, optarg);
                      break;
            case 'h':
            case '?':
            default:
                      usage(cmd_p);

          }
        } /*end of while*/
        if (optind != argc)
           usage(cmd_p);

        if (!strlen(SP_hostname)) 
           usage(cmd_p);

	(void) sigset(SIGPIPE, SIG_IGN);

	/*
	 * If stdin looks like a TLI endpoint, we assume
	 * that we were started by a port monitor. If
	 * t_getstate fails with TBADF, this is not a
	 * TLI endpoint.
	 */
	if (t_getstate(0) != -1 || t_errno != TBADF) {
		char *netid;
		struct netconfig *nconf = NULL;
		SVCXPRT *transp;
		int pmclose;

		_rpcpmstart = 1;
		openlog("mi_indicate", LOG_PID, LOG_DAEMON);

		if ((netid = getenv("NLSPROVIDER")) == NULL) {
		/* started from inetd */
			pmclose = 1;
		} else {
			if ((nconf = getnetconfigent(netid)) == NULL)
				_msgout("cannot get transport info");

			pmclose = (t_getstate(0) != T_DATAXFER);
		}
		if ((transp = svc_tli_create(0, nconf, NULL, 0, 0)) == NULL) {
			_msgout("cannot create server handle");
			exit(1);
		}
		if (nconf)
			freenetconfigent(nconf);
		if (!svc_reg(transp, DMI2_CLIENT, RMI2_CLIENT_VERSION, dmi2_client_0x1, 0)) {
			_msgout("unable to register (DMI2_CLIENT, RMI2_CLIENT_VERSION).");
			exit(1);
		}
		if (pmclose) {
			(void) signal(SIGALRM, (SIG_PF) closedown);
			(void) alarm(_RPCSVC_CLOSEDOWN/2);
		}

/***************************************************************************/
/*The following calls are required to establish connection with the Service    
  Provider, and  register with it.*/

  connectin.host = SP_hostname;
  connectin.nettype = "netpath";
  connectin.servertype = MISERVER;
  connectin.rpctype = ONC;

  if (!ConnectToServer(&connectin, &dmi_rpchandle)) {
     _msgout("ConnectToServer call failed");
     exit(1);
  }

  regin.handle = 0;
  DmiRegister(regin, &regout, &dmi_rpchandle );
  if (regout.error_status != DMIERR_NO_ERROR ) {
     _msgout("Error in registering with the Dmi");
     exit(1);
  }
/***************************************************************************/
/*The following calls are made to subscribe with the SP for events. And the
filter condition is set so as to receive all the different types of events .*/

                if (gethostname(hostname, sizeof(hostname))) {
                  _msgout("gethostname function failed ");
                   exit(1);
                }
                sprintf(subscriber_address,"%s:%ul:%ul",hostname,DMI2_CLIENT,
                                               RMI2_CLIENT_VERSION);

                /* Subscribe with the Service Provider for Event callbacks*/
                   subscribe_in.rpctype = "ONC RPC";    
                   subscribe_in.transport_type = "ncacn_ip_tcp";
                   subscribe_in.subscriber_addr = subscriber_address; 
                   subscribe_in.subscriber_id = 1;

/*The following values of warning/expiration time/failure threshold are only 
  example values. User may choose to change these values for testing the 
  behaviour, in accordance with the DMI2.0 specification.*/

                   subscribe_in.warn_time=
                      (DmiTimestamp_t *)"20101231120000.000000-420   ";

                   subscribe_in.exp_time=
                      (DmiTimestamp_t *)"20101231123000.000000-420   ";

                   subscribe_in.failure_threshold = 10;

                   if (!sp_indication_subscribe(&subscribe_in)) {
                        _msgout("Unable to subscribe with SP");
                         exit(1);
                   }

                /* Register One or more filter conditions , using the following
                   code or one or more times,  as appropriate */

                /* Set filter for selective event reporting*/
                   filter_in.rpctype = "ONC RPC";
                   filter_in.transport_type = "ncacn_ip_tcp";
                   filter_in.subscriber_addr = subscriber_address;
                   filter_in.subscriber_id = 1;

/*The following values of filters are only example values. User may choose 
  to change these values for testing the behaviour, in accordance with the
  DMI2.0 specification.*/

                  /*Pass for any component, any group class, or any type
                    of severity */

                   filter_in.componentid_filter= 0xFFFFFFFF;

                   filter_in.groupclass_filter= "||";

                   filter_in.severity_filter = 0xFFFFFFFF;


                   if (!set_event_filter(&filter_in)) {
                       _msgout("Unable to set the event filter");
                        exit(1);
                   }
/***************************************************************************/


		svc_run();
		exit(1);
		/* NOTREACHED */
	}	else {
#ifndef RPC_SVC_FG
		int size;
		struct rlimit rl;
		pid = fork();
		if (pid < 0) {
			perror("cannot fork");
			exit(1);
		}
		if (pid)
			exit(0);
		rl.rlim_max = 0;
		getrlimit(RLIMIT_NOFILE, &rl);
		if ((size = rl.rlim_max) == 0)
			exit(1);
		for (i = 0; i < size; i++)
			(void) close(i);
		i = open("/dev/null", 2);
		(void) dup2(i, 1);
		(void) dup2(i, 2);
		setsid();
		openlog("mi_indicate", LOG_PID, LOG_DAEMON);
#endif
	}
	if (!svc_create(dmi2_client_0x1, DMI2_CLIENT, RMI2_CLIENT_VERSION, "netpath")) {
		_msgout("unable to create (DMI2_CLIENT, RMI2_CLIENT_VERSION) for netpath.");
		exit(1);
	}

/***************************************************************************/
/*The following calls are required to establish connection with the Service    
  Provider, and  register with it.*/

  connectin.host = SP_hostname;
  connectin.nettype = "netpath";
  connectin.servertype = MISERVER;
  connectin.rpctype = ONC;

  if (!ConnectToServer(&connectin, &dmi_rpchandle)) {
     _msgout("ConnectToServer call failed");
     exit(1);
  }

  regin.handle = 0;
  DmiRegister(regin, &regout, &dmi_rpchandle );
  if (regout.error_status != DMIERR_NO_ERROR ) {
     _msgout("Error in registering with the Dmi");
     exit(1);
  }
/***************************************************************************/
/*The following calls are made to subscribe with the SP for events. And the
filter condition is set so as to receive all the different types of events .*/

                if (gethostname(hostname, sizeof(hostname))) {
                  _msgout("gethostname function failed ");
                   exit(1);
                }
                sprintf(subscriber_address,"%s:%ul:%ul",hostname,DMI2_CLIENT,
                                               RMI2_CLIENT_VERSION);

                /* Subscribe with the Service Provider for Event callbacks*/
                   subscribe_in.rpctype = "ONC RPC";    
                   subscribe_in.transport_type = "ncacn_ip_tcp";
                   subscribe_in.subscriber_addr = subscriber_address; 
                   subscribe_in.subscriber_id = 1;

/*The following values of warning/expiration time/failure threshold are only 
  example values. User may choose to change these values for testing the 
  behaviour, in accordance with the DMI2.0 specification.*/

                   subscribe_in.warn_time=
                      (DmiTimestamp_t *)"20101231120000.000000-420   ";

                   subscribe_in.exp_time=
                      (DmiTimestamp_t *)"20101231123000.000000-420   ";

                   subscribe_in.failure_threshold = 10;

                   if (!sp_indication_subscribe(&subscribe_in)) {
                        _msgout("Unable to subscribe with SP");
                         exit(1);
                   }

                /* Register One or more filter conditions , using the following
                   code or one or more times,  as appropriate */

                /* Set filter for selective event reporting*/
                   filter_in.rpctype = "ONC RPC";
                   filter_in.transport_type = "ncacn_ip_tcp";
                   filter_in.subscriber_addr = subscriber_address;
                   filter_in.subscriber_id = 1;

/*The following values of filters are only example values. User may choose 
  to change these values for testing the behaviour, in accordance with the
  DMI2.0 specification.*/

                  /*Pass for any component, any group class, or any type
                    of severity */

                   filter_in.componentid_filter= 0xFFFFFFFF;

                   filter_in.groupclass_filter= "||";

                   filter_in.severity_filter = 0xFFFFFFFF;


                   if (!set_event_filter(&filter_in)) {
                       _msgout("Unable to set the event filter");
                        exit(1);
                   }
/***************************************************************************/
	svc_run();
	_msgout("svc_run returned");
	exit(1);
	/* NOTREACHED */
}

int  sp_indication_subscribe(SubscriptionIN *subscribein) {

DmiListClassNamesIN    listclassnamesin;
DmiListClassNamesOUT   listclassnamesout;
DmiRowData_t           rowdata;
DmiClassNameInfo_t     *classnameinfo;
DmiString_t            className, rpctype, transtype, subaddr;
char                   buffer[200];
char                   hostname[100];
DmiAttributeValues_t   keylist_attrval, table_attrval;
DmiAttributeData_t     keylist_attrdat[7];
DmiAddRowIN            addrowin;
DmiAddRowOUT           addrowout;
int  count;

   memset(buffer, 0, sizeof(buffer));
/*Search for the Group Id of the Subscription Table */
   listclassnamesin.handle = 0;
   listclassnamesin.maxCount = 0;   /*For all the groups*/
   listclassnamesin.compId = 1;     /*The SP */
   DmiListClassNames(listclassnamesin, &listclassnamesout, &dmi_rpchandle);
   if (listclassnamesout.error_status != DMIERR_NO_ERROR) {
        _msgout("Error in Listing the Class Names of Compid = 1");
        return 0; 
   }
   
   if (!listclassnamesout.reply) {
      _msgout("Error: NULL DmiClassNameList_t* returned in DmiListClassNames");
      return 0;
   }
   
   classnameinfo = listclassnamesout.reply->list.list_val;
   if (!classnameinfo) {
      _msgout("Error:NULL DmiClassNameInfo_t* in the DmiClassNameList struct");
      return 0; 
   }

   for(count=0; count < listclassnamesout.reply->list.list_len; count++) {
        if (strstr(classnameinfo->className->body.body_val, 
                                "SP Indication Subscription") &&
             (classnameinfo->id != 0)) {
           break;
        }
        classnameinfo++;
   }  

   if (count == listclassnamesout.reply->list.list_len) {
      _msgout("Error:No class found for Indication Subscription");
      return 0;
   }

/*Frame the Subscription Entry in the DmiRowData Structure */   

   keylist_attrval.list.list_len = 4;
   keylist_attrval.list.list_val = keylist_attrdat;

   table_attrval.list.list_len = 7;
   table_attrval.list.list_val = keylist_attrdat;

   keylist_attrdat[0].id = 1;
   keylist_attrdat[0].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[0].data.DmiDataUnion_u.str = &rpctype;
   rpctype.body.body_len = strlen(subscribein->rpctype);
   rpctype.body.body_val = subscribein->rpctype;

   keylist_attrdat[1].id = 2;
   keylist_attrdat[1].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[1].data.DmiDataUnion_u.str = &transtype;
   transtype.body.body_len = strlen(subscribein->transport_type);
   transtype.body.body_val = subscribein->transport_type;

   subaddr.body.body_len = strlen(subscribein->subscriber_addr);
   subaddr.body.body_val = subscribein->subscriber_addr;

   keylist_attrdat[2].id = 3;
   keylist_attrdat[2].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[2].data.DmiDataUnion_u.str = &subaddr;

 
   keylist_attrdat[3].id = 4;
   keylist_attrdat[3].data.type = MIF_INTEGER;
   keylist_attrdat[3].data.DmiDataUnion_u.integer = subscribein->subscriber_id;

   keylist_attrdat[4].id = 5;
   keylist_attrdat[4].data.type = MIF_DATE;
   keylist_attrdat[4].data.DmiDataUnion_u.date= subscribein->warn_time;

   keylist_attrdat[5].id = 6;
   keylist_attrdat[5].data.type = MIF_DATE;
   keylist_attrdat[5].data.DmiDataUnion_u.date= subscribein->exp_time;

   keylist_attrdat[6].id = 7;
   keylist_attrdat[6].data.type = MIF_INTEGER;
  keylist_attrdat[6].data.DmiDataUnion_u.integer=subscribein->failure_threshold;


   rowdata.compId = 1;
   rowdata.groupId = classnameinfo->id;
   
   className.body.body_len = classnameinfo->className->body.body_len;
   className.body.body_val = 
              (char *)strdup(classnameinfo->className->body.body_val);
   
   rowdata.className = &className;
   rowdata.keyList   = &keylist_attrval; 
   rowdata.values    = &table_attrval;

   addrowin.handle = 0 ;
   addrowin.rowData = &rowdata;

   DmiAddRow(addrowin, &addrowout, &dmi_rpchandle);
   if ((addrowout.error_status != DMIERR_NO_ERROR) &&
      (addrowout.error_status != DMIERR_ROW_EXIST)) { 
      _msgout("Error in Adding Row for Subscription Table Entry");
      return 0;
   }

   return 1;   /*Successful in adding entry to the subscription table*/
}


int  set_event_filter(FilterInfoIN *filterin) {

DmiListClassNamesIN    listclassnamesin;
DmiListClassNamesOUT   listclassnamesout;
DmiRowData_t           rowdata;
DmiClassNameInfo_t     *classnameinfo;
DmiString_t            className, rpctype, transtype, subaddr, classfilt;
char                   buffer[200];
char                   hostname[100];
DmiAttributeValues_t   keylist_attrval, table_attrval;
DmiAttributeData_t     keylist_attrdat[7];
DmiAddRowIN            addrowin;
DmiAddRowOUT           addrowout;
int  count;

   memset(buffer, 0, sizeof(buffer));
/*Search for the Group Id of the Subscription Table */
   listclassnamesin.handle = 0;
   listclassnamesin.maxCount = 0;   /*For all the groups*/
   listclassnamesin.compId = 1;     /*The SP */
   DmiListClassNames(listclassnamesin, &listclassnamesout, &dmi_rpchandle);
   if (listclassnamesout.error_status != DMIERR_NO_ERROR) {
     _msgout("Error in Listing the Class Names of Compid=1");
     return 0;
   }
  
   if (!listclassnamesout.reply) {
      _msgout("Error: NULL DmiClassNameList_t* returned in DmiListClassNames");
      return 0;
   }
  
   classnameinfo = listclassnamesout.reply->list.list_val;
   if (!classnameinfo) {
      _msgout("Error:NULL DmiClassNameInfo_t* in the DmiClassNameList struct");
      return 0;
   }

   for(count=0; count < listclassnamesout.reply->list.list_len; count++) {
        if (strstr(classnameinfo->className->body.body_val,
                                "SPFilterInformation") && 
                   (classnameinfo->id != 0)) {
           break;
        }
        classnameinfo++;
   }

   if (count == listclassnamesout.reply->list.list_len) {
      _msgout("Error:No class found for Filter Information");
      return 0;
   }

/*Frame the Filter Entry in the DmiRowData Structure */

   keylist_attrval.list.list_len = 6;
   keylist_attrval.list.list_val = keylist_attrdat;

   table_attrval.list.list_len = 7;
   table_attrval.list.list_val = keylist_attrdat;

   keylist_attrdat[0].id = 1;
   keylist_attrdat[0].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[0].data.DmiDataUnion_u.str = &rpctype;
   rpctype.body.body_len = strlen(filterin->rpctype);
   rpctype.body.body_val = filterin->rpctype;

   keylist_attrdat[1].id = 2;
   keylist_attrdat[1].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[1].data.DmiDataUnion_u.str = &transtype;
   transtype.body.body_len = strlen(filterin->transport_type);
   transtype.body.body_val = filterin->transport_type;

   subaddr.body.body_len = strlen(filterin->subscriber_addr);
   subaddr.body.body_val = filterin->subscriber_addr;

   keylist_attrdat[2].id = 3;
   keylist_attrdat[2].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[2].data.DmiDataUnion_u.str = &subaddr;

   keylist_attrdat[3].id = 4;
   keylist_attrdat[3].data.type = MIF_INTEGER;
   keylist_attrdat[3].data.DmiDataUnion_u.integer = filterin->subscriber_id;

   keylist_attrdat[4].id = 5;
   keylist_attrdat[4].data.type = MIF_INTEGER;
   keylist_attrdat[4].data.DmiDataUnion_u.integer= filterin->componentid_filter;

   classfilt.body.body_len = strlen(filterin->groupclass_filter);
   classfilt.body.body_val = filterin->groupclass_filter;

   keylist_attrdat[5].id = 6;
   keylist_attrdat[5].data.type = MIF_DISPLAYSTRING;
   keylist_attrdat[5].data.DmiDataUnion_u.str=&classfilt;

   keylist_attrdat[6].id = 7;
   keylist_attrdat[6].data.type = MIF_INTEGER;
   keylist_attrdat[6].data.DmiDataUnion_u.integer = filterin->severity_filter;


   rowdata.compId = 1;
   rowdata.groupId = classnameinfo->id; 

   className.body.body_len = classnameinfo->className->body.body_len;
   className.body.body_val = 
                (char *)strdup(classnameinfo->className->body.body_val);

   rowdata.className = &className;
   rowdata.keyList   = &keylist_attrval;
   rowdata.values    = &table_attrval;

   addrowin.handle = 0;
   addrowin.rowData = &rowdata;

   DmiAddRow(addrowin, &addrowout, &dmi_rpchandle);
   if ((addrowout.error_status != DMIERR_NO_ERROR) &&
      (addrowout.error_status != DMIERR_ROW_EXIST)) { 
      _msgout("Error in Adding Row for Subscription Table Entry");
      return 0;
   }

   return 1; /*Successful in setting the filter */

}


DmiErrorStatus_t *
_dmideliverevent_0x1_svc(DmiDeliverEventIN *argp, struct svc_req *rqstp)
{
        static DmiErrorStatus_t  result;
        /*
         * insert server code here
         */
        result = DMIERR_NO_ERROR;
        printf("Received Deliver Event Callback\n");
        return(&result);
}

DmiErrorStatus_t *
_dmicomponentadded_0x1_svc(DmiComponentAddedIN *argp, struct svc_req *rqstp) 
{
        static DmiErrorStatus_t  result;
        /*
         * insert server code here
         */

        result = DMIERR_NO_ERROR;
        printf("Received Component Added callback\n");
        return(&result);
}

DmiErrorStatus_t *
_dmicomponentdeleted_0x1_svc(DmiComponentDeletedIN *argp, struct svc_req *rqstp){
        static DmiErrorStatus_t  result;
        /*
         * insert server code here
         */

        result = DMIERR_NO_ERROR;
        printf("Received Component Deleted callback\n");
        return(&result);
}

DmiErrorStatus_t *
_dmilanguageadded_0x1_svc(DmiLanguageAddedIN *argp, struct svc_req *rqstp)
{
        static DmiErrorStatus_t  result;
        /*
         * insert server code here
         */

        result = DMIERR_NO_ERROR;
        printf("Received Language Added callback\n");
        return(&result);

}

DmiErrorStatus_t *
_dmilanguagedeleted_0x1_svc(DmiLanguageDeletedIN *argp, struct svc_req *rqstp)
{
        static DmiErrorStatus_t  result;
        /*
         * insert server code here
         */
        result = DMIERR_NO_ERROR;
        printf("Received Language Deleted callback\n");
        return(&result);

}

DmiErrorStatus_t *
_dmigroupadded_0x1_svc(DmiGroupAddedIN *argp, struct svc_req *rqstp)
{
        static DmiErrorStatus_t  result;
        /*
         * insert server code here
         */
        result = DMIERR_NO_ERROR;
        printf("Received Group Added callback\n");
        return(&result);


}

DmiErrorStatus_t *
_dmigroupdeleted_0x1_svc(DmiGroupDeletedIN *argp, struct svc_req *rqstp)
{
        static DmiErrorStatus_t  result;

        /*
         * insert server code here
         */
        result = DMIERR_NO_ERROR;
        printf("Received Group Deleted callback\n");
        return(&result);
}

DmiErrorStatus_t *
_dmisubscriptionnotice_0x1_svc(DmiSubscriptionNoticeIN *argp, struct svc_req *rqstp)
{
        static DmiErrorStatus_t  result;

        /*
         * insert server code here
         */
        result = DMIERR_NO_ERROR;
        printf("Received Subscription Notice callback\n");
        return(&result);
}
